<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java Regex Group Name | Greg. I/O</title>
<meta name="keywords" content="fr, java, regex, group name">
<meta name="description" content="Lors du développement d&rsquo;un programme informatique, il est souvent nécessaire d&rsquo;utiliser les expressions rationnelles (ou &ldquo;regular expressions&rdquo; en anglais, parfois traduites par &ldquo;expressions régulières&rdquo;). Ces expressions constituent un outil puissant lorsqu&rsquo;il s&rsquo;agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu&rsquo;un texte correspond à un format particulier.
Dans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d&rsquo;expressions rationnelles (ou regex) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.">
<meta name="author" content="">
<link rel="canonical" href="https://gautric.github.io/blog/2015/06/18/java-regex-group-name/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8f91d8a03d2d03df35a93d161da5378cfcf6b504ad2ef312c29e142e3806a327.css" integrity="sha256-j5HYoD0tA981qT0WHaU3jPz2tQStLvMSwp4ULjgGoyc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="apple-touch-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="mask-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://gautric.github.io/blog/2015/06/18/java-regex-group-name/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://gautric.github.io/blog/2015/06/18/java-regex-group-name/">
  <meta property="og:site_name" content="Greg. I/O">
  <meta property="og:title" content="Java Regex Group Name">
  <meta property="og:description" content="Lors du développement d’un programme informatique, il est souvent nécessaire d’utiliser les expressions rationnelles (ou “regular expressions” en anglais, parfois traduites par “expressions régulières”). Ces expressions constituent un outil puissant lorsqu’il s’agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu’un texte correspond à un format particulier.
Dans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d’expressions rationnelles (ou regex) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-06-18T13:58:00+00:00">
    <meta property="article:modified_time" content="2015-06-18T13:58:00+00:00">
    <meta property="article:tag" content="Fr">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="Regex">
    <meta property="article:tag" content="Group Name">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Regex Group Name">
<meta name="twitter:description" content="Lors du développement d&rsquo;un programme informatique, il est souvent nécessaire d&rsquo;utiliser les expressions rationnelles (ou &ldquo;regular expressions&rdquo; en anglais, parfois traduites par &ldquo;expressions régulières&rdquo;). Ces expressions constituent un outil puissant lorsqu&rsquo;il s&rsquo;agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu&rsquo;un texte correspond à un format particulier.
Dans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d&rsquo;expressions rationnelles (ou regex) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.">
      <meta name="twitter:site" content="@gautric_io">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://gautric.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Java Regex Group Name",
      "item": "https://gautric.github.io/blog/2015/06/18/java-regex-group-name/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java Regex Group Name",
  "name": "Java Regex Group Name",
  "description": "Lors du développement d\u0026rsquo;un programme informatique, il est souvent nécessaire d\u0026rsquo;utiliser les expressions rationnelles (ou \u0026ldquo;regular expressions\u0026rdquo; en anglais, parfois traduites par \u0026ldquo;expressions régulières\u0026rdquo;). Ces expressions constituent un outil puissant lorsqu\u0026rsquo;il s\u0026rsquo;agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu\u0026rsquo;un texte correspond à un format particulier.\nDans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d\u0026rsquo;expressions rationnelles (ou regex) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.\n",
  "keywords": [
    "fr", "java", "regex", "group name"
  ],
  "articleBody": "Lors du développement d’un programme informatique, il est souvent nécessaire d’utiliser les expressions rationnelles (ou “regular expressions” en anglais, parfois traduites par “expressions régulières”). Ces expressions constituent un outil puissant lorsqu’il s’agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu’un texte correspond à un format particulier.\nDans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d’expressions rationnelles (ou regex) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.\nUse case : tester les URL Dans notre cas d’utilisation, nous souhaitons vérifier si une chaîne de caractères correspond bien au format d’une URL. Pour cela, nous allons créer une expression rationnelle qui permettra de valider cette correspondance.\n(?http|ftp|ssh|amqp|imap|ws)(?s)?://(?[a-zA-Z.-]+)(:(?[0-9]+))? Cette expression rationnelle permet de décomposer une URL en plusieurs éléments :\nLe protocole (http, ftp, ssh, etc.) Un indicateur de sécurité optionnel (“s”) Le nom d’hôte Un numéro de port optionnel Avec cette « regex », il est possible de vérifier des chaînes comme les exemples suivants :\nftp://fileserver.domain:1223 imaps://emailserver.domain:341 Group indexé Dans la plupart des langages supportant les expressions rationnelles, il est possible de récupérer les différentes parties capturées grâce à la notion de group indexé. Par exemple, le premier group (généralement accessible via group(1)) va correspondre au schéma de l’URL (http, ftp, amqp, etc.), le second groupe à un autre élément, et ainsi de suite.\nCette approche par index fonctionne, mais peut devenir difficile à maintenir lorsque l’expression rationnelle évolue, car les indices des groupes peuvent changer.\nGroup nommé Java offre une fonctionnalité particulièrement élégante (également disponible dans certains autres langages comme Python) : la possibilité de nommer les groupes de capture. Cette approche rend le code plus lisible et plus robuste face aux modifications. Voici comment définir des groupes nommés :\n\"(?http|ftp|ssh|amqp|imap|ws)(?s)?://(?[a-zA-Z.-]+)(:(?[0-9]+))?\" Dans cette expression, nous avons défini quatre groupes nommés :\nscheme : capture le protocole secure : capture la présence ou non du “s” (sécurisé) host : capture le nom d’hôte port : capture le numéro de port s’il est présent Ensuite, il est possible de retrouver la valeur capturée par l’expression rationnelle en utilisant le nom du groupe, comme ceci : group(\"scheme\"), group(\"host\"), etc.\nVoici un exemple complet de l’utilisation des groupes nommés avec Java :\nEt voici le résultat de l’exécution de ce code :\nscheme : ftp secure : false host : fileserver.domain port : 1223 scheme : amqp secure : false host : momserver.domain port : 999 scheme : imap secure : true host : emailserver.domain port : 341 scheme : ws secure : true host : pushserver.domain port : 433 Conclusion L’utilisation des expressions rationnelles permet de simplifier considérablement certaines problématiques de développement, notamment pour la validation et l’extraction de données textuelles. Malheureusement, elles sont parfois sous-utilisées par les développeurs en raison de leur syntaxe qui peut paraître obscure au premier abord.\nLes groupes nommés constituent une amélioration significative de la lisibilité et de la maintenabilité du code utilisant des expressions rationnelles. En rendant le code plus explicite et autodocumenté, cette fonctionnalité peut encourager davantage de développeurs à tirer parti de la puissance des expressions rationnelles dans leurs projets Java.\n",
  "wordCount" : "535",
  "inLanguage": "en",
  "datePublished": "2015-06-18T13:58:00Z",
  "dateModified": "2015-06-18T13:58:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gautric.github.io/blog/2015/06/18/java-regex-group-name/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Greg. I/O",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gautric.github.io/apple-icon-180x180.png"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gautric.github.io/" accesskey="h" title="Greg. I/O (Alt + H)">
                <img src="https://gautric.github.io/apple-icon-180x180.png" alt="" aria-label="logo"
                    height="35">Greg. I/O</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gautric.github.io/apropos/" title="À Propos">
                    <span>À Propos</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/contact/" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://gautric.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://gautric.github.io/blog/">Blog</a></div>
    <h1 class="post-title entry-hint-parent">
      Java Regex Group Name
    </h1>
    <div class="post-meta"><span title='2015-06-18 13:58:00 +0000 UTC'>June 18, 2015</span>

</div>
  </header> 
  <div class="post-content"><p>Lors du développement d&rsquo;un programme informatique, il est souvent nécessaire d&rsquo;utiliser les expressions rationnelles (ou &ldquo;regular expressions&rdquo; en anglais, parfois traduites par &ldquo;expressions régulières&rdquo;). Ces expressions constituent un outil puissant lorsqu&rsquo;il s&rsquo;agit de rechercher des motifs spécifiques dans des chaînes de caractères ou de vérifier qu&rsquo;un texte correspond à un format particulier.</p>
<p>Dans tous les langages de programmation modernes comme Java, Ruby ou Python, les bibliothèques d&rsquo;expressions rationnelles (ou <em>regex</em>) sont disponibles en standard. Dans cet article, nous allons explorer une fonctionnalité particulièrement intéressante disponible dans la bibliothèque standard de Java : les groupes nommés.</p>
<h2 id="use-case--tester-les-url">Use case : tester les URL<a hidden class="anchor" aria-hidden="true" href="#use-case--tester-les-url">#</a></h2>
<p>Dans notre cas d&rsquo;utilisation, nous souhaitons vérifier si une chaîne de caractères correspond bien au format d&rsquo;une URL. Pour cela, nous allons créer une expression rationnelle qui permettra de valider cette correspondance.</p>
<pre tabindex="0"><code>(?http|ftp|ssh|amqp|imap|ws)(?s)?://(?[a-zA-Z.-]+)(:(?[0-9]+))?
</code></pre><p>Cette expression rationnelle permet de décomposer une URL en plusieurs éléments :</p>
<ul>
<li>Le protocole (http, ftp, ssh, etc.)</li>
<li>Un indicateur de sécurité optionnel (&ldquo;s&rdquo;)</li>
<li>Le nom d&rsquo;hôte</li>
<li>Un numéro de port optionnel</li>
</ul>
<p>Avec cette « regex », il est possible de vérifier des chaînes comme les exemples suivants :</p>
<pre tabindex="0"><code>ftp://fileserver.domain:1223
imaps://emailserver.domain:341
</code></pre><h2 id="group-indexé"><em>Group</em> indexé<a hidden class="anchor" aria-hidden="true" href="#group-indexé">#</a></h2>
<p>Dans la plupart des langages supportant les expressions rationnelles, il est possible de récupérer les différentes parties capturées grâce à la notion de <em>group</em> indexé. Par exemple, le premier <em>group</em> (généralement accessible via <code>group(1)</code>) va correspondre au schéma de l&rsquo;URL (http, ftp, amqp, etc.), le second groupe à un autre élément, et ainsi de suite.</p>
<p>Cette approche par index fonctionne, mais peut devenir difficile à maintenir lorsque l&rsquo;expression rationnelle évolue, car les indices des groupes peuvent changer.</p>
<h2 id="group-nommé"><em>Group</em> nommé<a hidden class="anchor" aria-hidden="true" href="#group-nommé">#</a></h2>
<p>Java offre une fonctionnalité particulièrement élégante (également disponible dans certains autres langages comme Python) : la possibilité de nommer les groupes de capture. Cette approche rend le code plus lisible et plus robuste face aux modifications. Voici comment définir des groupes nommés :</p>
<pre tabindex="0"><code>&#34;(?&lt;scheme&gt;http|ftp|ssh|amqp|imap|ws)(?&lt;secure&gt;s)?://(?&lt;host&gt;[a-zA-Z.-]+)(:(?&lt;port&gt;[0-9]+))?&#34;
</code></pre><p>Dans cette expression, nous avons défini quatre groupes nommés :</p>
<ul>
<li><code>scheme</code> : capture le protocole</li>
<li><code>secure</code> : capture la présence ou non du &ldquo;s&rdquo; (sécurisé)</li>
<li><code>host</code> : capture le nom d&rsquo;hôte</li>
<li><code>port</code> : capture le numéro de port s&rsquo;il est présent</li>
</ul>
<p>Ensuite, il est possible de retrouver la valeur capturée par l&rsquo;expression rationnelle en utilisant le nom du groupe, comme ceci : <code>group(&quot;scheme&quot;)</code>, <code>group(&quot;host&quot;)</code>, etc.</p>
<p>Voici un exemple complet de l&rsquo;utilisation des groupes nommés avec Java :</p>
<script src="https://gist.github.com/gautric/45c3f5c1a9566f83e50d.js"></script>
<p>Et voici le résultat de l&rsquo;exécution de ce code :</p>
<pre tabindex="0"><code>scheme 	: ftp
secure 	: false
host 	: fileserver.domain
port 	: 1223
scheme 	: amqp
secure 	: false
host 	: momserver.domain
port 	: 999
scheme 	: imap
secure 	: true
host 	: emailserver.domain
port 	: 341
scheme 	: ws
secure 	: true
host 	: pushserver.domain
port 	: 433
</code></pre><br/>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>L&rsquo;utilisation des expressions rationnelles permet de simplifier considérablement certaines problématiques de développement, notamment pour la validation et l&rsquo;extraction de données textuelles. Malheureusement, elles sont parfois sous-utilisées par les développeurs en raison de leur syntaxe qui peut paraître obscure au premier abord.</p>
<p>Les groupes nommés constituent une amélioration significative de la lisibilité et de la maintenabilité du code utilisant des expressions rationnelles. En rendant le code plus explicite et autodocumenté, cette fonctionnalité peut encourager davantage de développeurs à tirer parti de la puissance des expressions rationnelles dans leurs projets Java.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://gautric.github.io/tags/fr/">Fr</a></li>
      <li><a href="https://gautric.github.io/tags/java/">Java</a></li>
      <li><a href="https://gautric.github.io/tags/regex/">Regex</a></li>
      <li><a href="https://gautric.github.io/tags/group-name/">Group Name</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://gautric.github.io/blog/2015/07/01/leshan-et-le-standard-lightweight-m2m-%C3%A0-leclipsecon/">
    <span class="title">« Prev</span>
    <br>
    <span>Leshan et le standard Lightweight M2M à l&#39;EclipseCon</span>
  </a>
  <a class="next" href="https://gautric.github.io/blog/2015/05/20/camel-iot-labs-i2c-gpio-mqtt-lcd/">
    <span class="title">Next »</span>
    <br>
    <span>Camel IoT Labs i2c gpio mqtt lcd</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2016 - 2025 <a href="https://gautric.github.io/">Greg. I/O</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
