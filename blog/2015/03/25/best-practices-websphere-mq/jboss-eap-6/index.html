<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Best Practices Websphere MQ/JBoss EAP 6 | Greg. I/O</title>
<meta name="keywords" content="fr, jboss, eap, wildfly, websphereMQ, JCA">
<meta name="description" content="Le serveur d&rsquo;application JBoss EAP est certifié JAVA EE 6, il implémente donc via le framework IronJacamar le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l&rsquo;analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d&rsquo;intégrer tout type de systèmes d’informations d’entreprise (EIS)">
<meta name="author" content="">
<link rel="canonical" href="https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.26cca5596cf53898626a540511b92ee26f2bfa182bb8ac88d95536b8581f7899.css" integrity="sha256-JsylWWz1OJhialQFEbku4m8r&#43;hgruKyI2VU2uFgfeJk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="apple-touch-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="mask-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/index.xml">
<link rel="alternate" hreflang="en" href="https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-60791597-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Best Practices Websphere MQ/JBoss EAP 6" />
<meta property="og:description" content="Le serveur d&rsquo;application JBoss EAP est certifié JAVA EE 6, il implémente donc via le framework IronJacamar le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l&rsquo;analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d&rsquo;intégrer tout type de systèmes d’informations d’entreprise (EIS)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-25T13:58:00+00:00" />
<meta property="article:modified_time" content="2015-03-25T13:58:00+00:00" /><meta property="og:site_name" content="Greg. I/O" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Best Practices Websphere MQ/JBoss EAP 6"/>
<meta name="twitter:description" content="Le serveur d&rsquo;application JBoss EAP est certifié JAVA EE 6, il implémente donc via le framework IronJacamar le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l&rsquo;analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d&rsquo;intégrer tout type de systèmes d’informations d’entreprise (EIS)"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://gautric.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Best Practices Websphere MQ/JBoss EAP 6",
      "item": "https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Best Practices Websphere MQ/JBoss EAP 6",
  "name": "Best Practices Websphere MQ\/JBoss EAP 6",
  "description": "Le serveur d\u0026rsquo;application JBoss EAP est certifié JAVA EE 6, il implémente donc via le framework IronJacamar le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l\u0026rsquo;analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d\u0026rsquo;intégrer tout type de systèmes d’informations d’entreprise (EIS)",
  "keywords": [
    "fr", "jboss", "eap", "wildfly", "websphereMQ", "JCA"
  ],
  "articleBody": "Le serveur d’application JBoss EAP est certifié JAVA EE 6, il implémente donc via le framework IronJacamar le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l’analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d’intégrer tout type de systèmes d’informations d’entreprise (EIS)\nLe standard JCA va prendre en charge l’ensemble des fonctionnalités suivantes (liste non-exhaustive) :\nConnexion au système (socket, IPC, …) Gestion des transactions (locales, XA) Sécurisation de l’accès à la ressource distante Management du cycle de vie et du threading Le fournisseur de service va fournir aux développeurs et à l’intégrateur un driver appelé dans le contexte JCA : Resource Adapter\nNous allons voir dans notre exemple :\nBest Pratice d’integration JMS entre Websphere MQ (WMQ) et JBoss EAP 6\nMatériels Pour ce lab, nous allons avoir besoin de deux logiciels :\nUn serveur JBoss EAP http://www.jboss.org/products/eap/download/ Un serveur WebSphereMQ http://www.ibm.com/developerworks/downloads/ws/wmq/ Le ressource adapteur disponible dans le répertoire /opt/mqm/java/lib/jca Warning\nAttention, il s’agit de version d’essai ou d’évaluation uniquement, le déploiement en production nécessite l’achat de souscription pour JBoss et de license pour IBM\nDéveloppement Afin de pouvoir tester notre intégration nous allons avoir besoin de développer un client pour l’envoi et un MDB pour la réception d’un message JMS.\nPour l’envoi Dans notre cas nous allons créer un EJB Stateless pour envoyer le message JMS. Mais il est possible d’utiliser un autre mécanisme pour l’envoi, une servlet par exemple.\n// ..OMIT .. // @Stateless public class MoMSenderBean { // ..OMIT .. // @Resource(name = \"jms/connectionFactory\") ConnectionFactory factory; @Resource(name = \"jms/queue/Queue\") Queue queue; public void sendMessage(String message) throws JMSException { Connection connection = factory.createConnection(); LOGGER.trace(\"Recuperation d'une connexion {}\", connection); Session session = connection.createSession(false, AUTO_ACKNOWLEDGE); MessageProducer producer = session.createProducer(queue); LOGGER.trace(\"Creation du sender {} sur la queue {}\", producer, queue); TextMessage textMessage = session.createTextMessage(message); textMessage.setJMSCorrelationID(UUID.randomUUID().toString()); producer.send(textMessage); producer.close(); session.close(); connection.close(); } } Warning\nOn notera dans ce code que les ressources JMS (Factory et Queue) sont récupérées du scope courant du module.\nPlus d’information sur JNDI avec JBoss\nPour la réception Dans le monde Java EE, la réception de message JMS se fait par l’intermediaire d’un bean particulier. Ce bean est un Message Driven Bean (MDB), c’est à dire que l’objet est appelé quand un message est reçu dans la file JMS. La classe doit héritée de l’interface javax.jms.MessageListener\n// ..OMIT .. // public class MoMMDB implements MessageListener { // ..OMIT .. // public void onMessage(Message message) { LOGGER.info(\"Received Message from queue: {}\" + (TextMessage) message); } } Warning\nIl est bien sûr possible décorer le MDB avec les annotations ActivationSpec, mais ces annotations noie dans le code des problematiques contextuelles à l’application (environnement extérieur à l’application). Avec d’autre resource adapter cela peut s’avérer plus simple.\nConfiguration Application Nous allons maintenant configurer l’application afin de nous connecter à la bonne file JMS. Dans un premier temps nous allons utiliser le fichier ejb-jar.xml afin de definir les principaux objets.\nDéfinition Java EE (ejb-jar.xml) MoM Application EJB / MDB MoM Application EJB / MDB MoM MDB MessageDrivenBean net.a.g.jee.mom.mdb.MoMMDB Container javax.jms.Queue MoMSenderBean net.a.g.jee.mom.ejb.MoMSenderBean Configuration des implementations spécifiques (jboss-ejb3.xml) Comme nous souhaitons pouvoir nous connecter à un serveur WebsphereMQ nous allons devoir configurer le MDB afin qu’il réceptionne les messages. On effectura aussi le mapping des ressources d’environnement du serveur d’application avec les resources de l’application.\nMessageDrivenBean net.a.g.jee.mom.mdb.MoMMDB Container javax.jms.Queue channel ${websphere.channel} queueManager ${websphere.queueManager} transportType ${websphere.transportType} hostName ${websphere.hostName} port ${websphere.port} username ${websphere.username} password ${websphere.password} destination java:/jboss/jms/wmq/queue/Queue useJNDI true destinationType javax.jms.Queue MoMSenderBean net.a.g.jee.mom.ejb.MoMSenderBean jms/connectionFactory javax.jms.ConnectionFactory java:/jboss/jms/wmq/connectionFactory jms/queue/Queue java:/jboss/jms/wmq/queue/Queue MessageDrivenBean ${websphere.resource.adapter} Plusieurs points importants dans cette configuration sont à noter :\nL’utilisation de placeholder dans l’ensemble des configurations techniques afin de centraliser l’information dans le standalone.xml hostName -\u003e ${websphere.hostName} port -\u003e ${websphere.port} queueManager -\u003e ${websphere.queueManager} La propriété useJNDI est activée afin de récuperer la queue par son nom JNDI Le mapping des noms JNDI du serveur JBoss avec les noms JNDI du module applicatif Nom de la queue configurée dans le serveur : java:/jboss/jms/wmq/queue/Queue Nom de la queue utilisée par le module applicatif : jms/queue/Queue Le binding du ressource adapteur (driver JCA) de websphere MQ au bean MDB de réception. Balise Warning\nIl est preferable d’utiliser les fichiers XML dans un contexte d’entreprise, en effet le changement d’environement et les fréquentes modifications nécessite souvent des mises à jour d’informations. Le code Java doit dépendre le moins possible de l’environnement et de l’implémentation des systèmes externes.\nInfo\nSi l’application doit se connecter à un autre système JMS, je preconise de recréer un autre fichier jboss-ejb3.xml, le mapping sera de nouveau à effectuer dans ce fichier.\nConfiguration JBoss Dans ce chapitre nous allons voir comment configurer le fichier standalone.xml de l’instance JBoss EAP.\nLes systèmes properties Nous reprennons ici l’ensembles des variables d’environnement de connexion à WebsphereMQ que nous avons vu dans le fichier jboss-ejb3.xml.\nInfo\nLe mode BINDING est le second type de transport possible pour la connexion à WebsphereMQ, mais il nécessite l’installation de composant binaires spécifiques aux systèmes d’exploitation.\nLe mécanisme de remplacement JBoss va utiliser les variables d’environnement et va les remplacer dans certain type objet de l’application.\nIl y a trois types de fichier dans lesquels JBoss peut remplacer les placeholder par les variables d’environnement :\nLes fichiers descripteurs du standard Java EE spec-descriptor-property-replacement web.xml, ejb-jar.xml, etc… Les fichiers descripteurs spécifiques à JBoss jboss-descriptor-property-replacement jboss-web.xml, jboss-ejb3.xml, etc… Les annotations annotation-property-replacement false true false Note\nJe préconise d’effectuer le remplacement uniquement pour les fichiers descripteurs JBoss, car cela est spécifique à JBoss.\nLe ressource adapteur pour la connexion à WMQ Enfin pour terminer, nous allons configurer le ressource adapteur dans l’instance JBoss.\nwmq.jmsra.rar LocalTransaction ${websphere.port:1414} ${websphere.hostName:localhost} ${websphere.username:mqm} ${websphere.password:mqm} ${websphere.channel:SYSTEM.AUTO.SVRCONN} ${websphere.transportType:CLIENT} ${websphere.queueManager:QUEUE.MANAGER} ${websphere.queueManager:QUEUE.MANAGER} ${websphere.queueName:Q_QUEUE} Info\nOn remarquera l’utilisation des placeholders dans cette partie de configuration du fichier standalone.xml\nIl nous reste plus qu’à déposer le resource adapter de Websphere MQ wmq.jmsra.rar et notre application dans le répertoire de déploiement de l’instance de JBoss ${JBOSS_HOME}/standalone/deployments, et le tour est joué.\nConclusion L’intégration du connecteur WebsphereMQ est relativement aisé dans le serveur d’application JBoss. En respectant les principes de ce post, il est possible d’obtenir une application modulaire et facile à maintenir. Le déploiement sur différents environnements (DEV, INT, PROD) en est simplifié, seules les variables d’environnements dans le fichier standalone.xml sont à modifier.\nURL https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Administration_and_Configuration_Guide/Deploy_the_WebSphere_MQ_Resource_Adapter.html https://developer.jboss.org/message/738670 https://developer.jboss.org/wiki/WebsphereMQIntegration The installation verification test program for the WebSphere MQ resource adapter {% flag uk %} English version Remerciements Akram B. A. @RedHat pour certaines ressources de ce post Guillaume C. @RedHat pour ces conseils ",
  "wordCount" : "1244",
  "inLanguage": "en",
  "datePublished": "2015-03-25T13:58:00Z",
  "dateModified": "2015-03-25T13:58:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gautric.github.io/blog/2015/03/25/best-practices-websphere-mq/jboss-eap-6/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Greg. I/O",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gautric.github.io/apple-icon-180x180.png"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gautric.github.io/" accesskey="h" title="Greg. I/O (Alt + H)">
                <img src="https://gautric.github.io/apple-icon-180x180.png" alt="" aria-label="logo"
                    height="35">Greg. I/O</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gautric.github.io/apropos/" title="À Propos">
                    <span>À Propos</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/contact/" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://gautric.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://gautric.github.io/blog/">Blog</a></div>
    <h1 class="post-title entry-hint-parent">
      Best Practices Websphere MQ/JBoss EAP 6
    </h1>
    <div class="post-meta"><span title='2015-03-25 13:58:00 +0000 UTC'>March 25, 2015</span>

</div>
  </header> 
  <div class="post-content"><p>Le serveur d&rsquo;application <a href="http://www.jboss.org/products/eap/overview/">JBoss EAP</a> est <a href="http://www.oracle.com/technetwork/java/javaee/overview/compatibility-jsp-136984.html">certifié JAVA EE 6</a>, il implémente donc via le framework <a href="http://www.ironjacamar.org/">IronJacamar</a> le standard JAVA EE Connector Architecture (JCA). Ce standard permet de connecter les applications Java EE à des ressources externes comme par exemple un broker JMS, un système de fichier ou un mainframe. Il est possible de faire l&rsquo;analogie du standard JCA avec le standard JDBC, JDBC se limitant uniquement aux bases de données de type relationnel, JCA se veut beaucoup plus large, il permet d&rsquo;intégrer tout type de systèmes d’informations d’entreprise (EIS)</p>
<p>Le standard JCA va prendre en charge l&rsquo;ensemble des fonctionnalités suivantes (liste non-exhaustive) :</p>
<ul>
<li>Connexion au système (socket, IPC, &hellip;)</li>
<li>Gestion des transactions (locales, XA)</li>
<li>Sécurisation de l&rsquo;accès à la ressource distante</li>
<li>Management du cycle de vie et du threading</li>
</ul>
<p>Le fournisseur de service va fournir aux développeurs et à l&rsquo;intégrateur un driver appelé dans le contexte JCA : <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gipgl.html">Resource Adapter</a></p>
<p>Nous allons voir dans notre exemple :</p>
<blockquote>
<p>Best Pratice d&rsquo;integration JMS entre Websphere MQ (WMQ) et JBoss EAP 6</p>
</blockquote>
<h2 id="matériels">Matériels<a hidden class="anchor" aria-hidden="true" href="#matériels">#</a></h2>
<p>Pour ce lab, nous allons avoir besoin de deux logiciels :</p>
<ul>
<li>Un serveur JBoss EAP <a href="http://www.jboss.org/products/eap/download/">http://www.jboss.org/products/eap/download/</a></li>
<li>Un serveur WebSphereMQ <a href="http://www.ibm.com/developerworks/downloads/ws/wmq/">http://www.ibm.com/developerworks/downloads/ws/wmq/</a>
<ul>
<li>Le ressource adapteur disponible dans le répertoire <strong>/opt/mqm/java/lib/jca</strong></li>
</ul>
</li>
</ul>
<div><svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg></div><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>Attention, il s&rsquo;agit de version d&rsquo;essai ou d&rsquo;évaluation uniquement, le déploiement en production nécessite l&rsquo;achat de souscription pour JBoss et de license pour IBM</p></div>

<h2 id="développement">Développement<a hidden class="anchor" aria-hidden="true" href="#développement">#</a></h2>
<p>Afin de pouvoir tester notre intégration nous allons avoir besoin de développer un client pour l&rsquo;envoi et un MDB pour la réception d&rsquo;un message JMS.</p>
<h3 id="pour-lenvoi">Pour l&rsquo;envoi<a hidden class="anchor" aria-hidden="true" href="#pour-lenvoi">#</a></h3>
<p>Dans notre cas nous allons créer un EJB Stateless pour envoyer le message JMS. Mais il est possible d&rsquo;utiliser un autre mécanisme pour l&rsquo;envoi, une servlet par exemple.</p>
<pre tabindex="0"><code>  // ..OMIT .. //

  @Stateless
  public class MoMSenderBean {

    // ..OMIT .. //

    @Resource(name = &#34;jms/connectionFactory&#34;)
    ConnectionFactory factory;

    @Resource(name = &#34;jms/queue/Queue&#34;)
    Queue queue;

    public void sendMessage(String message) throws JMSException {

              Connection connection = factory.createConnection();
              LOGGER.trace(&#34;Recuperation d&#39;une connexion {}&#34;, connection);

              Session session = connection.createSession(false, AUTO_ACKNOWLEDGE);
              MessageProducer producer = session.createProducer(queue);
              LOGGER.trace(&#34;Creation du sender {} sur la queue {}&#34;, producer, queue);

              TextMessage textMessage = session.createTextMessage(message);
              textMessage.setJMSCorrelationID(UUID.randomUUID().toString());
              producer.send(textMessage);
              producer.close();
              session.close();
              connection.close();
    }
  }
</code></pre><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>On notera dans ce code que les ressources JMS (Factory et Queue) sont récupérées du scope courant du module.</p></div>

<p>Plus d&rsquo;information sur <a href="https://docs.jboss.org/author/display/AS72/JNDI+Reference">JNDI avec JBoss</a></p>
<h3 id="pour-la-réception">Pour la réception<a hidden class="anchor" aria-hidden="true" href="#pour-la-réception">#</a></h3>
<p>Dans le monde Java EE, la réception de message JMS se fait par l&rsquo;intermediaire d&rsquo;un bean particulier.
Ce bean est un Message Driven Bean (MDB), c&rsquo;est à dire que l&rsquo;objet est appelé quand un message est reçu dans la file JMS.
La classe doit héritée de l&rsquo;interface <strong>javax.jms.MessageListener</strong></p>
<pre tabindex="0"><code>// ..OMIT .. //

public class MoMMDB implements MessageListener {

  // ..OMIT .. //

	public void onMessage(Message message) {
		LOGGER.info(&#34;Received Message from queue: {}&#34; + (TextMessage) message);

	}
}
</code></pre><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>Il est bien sûr possible décorer le MDB avec les annotations ActivationSpec, mais ces annotations noie dans le code des problematiques contextuelles à l&rsquo;application (environnement extérieur à l&rsquo;application). Avec d&rsquo;autre resource adapter cela peut s&rsquo;avérer plus simple.</p></div>

<h2 id="configuration-application">Configuration Application<a hidden class="anchor" aria-hidden="true" href="#configuration-application">#</a></h2>
<p>Nous allons maintenant configurer l&rsquo;application afin de nous connecter à la bonne file JMS.
Dans un premier temps nous allons utiliser le fichier <em>ejb-jar.xml</em> afin de definir les principaux objets.</p>
<h3 id="définition-java-ee-ejb-jarxml">Définition Java EE (ejb-jar.xml)<a hidden class="anchor" aria-hidden="true" href="#définition-java-ee-ejb-jarxml">#</a></h3>
<pre tabindex="0"><code>&lt;ejb-jar xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34; xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd&#34; version=&#34;3.0&#34;&gt;
  &lt;description&gt;MoM Application EJB / MDB &lt;/description&gt;
  &lt;display-name&gt;MoM Application EJB / MDB&lt;/display-name&gt;
  &lt;enterprise-beans&gt;
    &lt;message-driven&gt;
      &lt;description&gt;MoM MDB&lt;/description&gt;
      &lt;ejb-name&gt;MessageDrivenBean&lt;/ejb-name&gt;
      &lt;ejb-class&gt;net.a.g.jee.mom.mdb.MoMMDB&lt;/ejb-class&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
      &lt;message-destination-type&gt;javax.jms.Queue&lt;/message-destination-type&gt;
    &lt;/message-driven&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;MoMSenderBean&lt;/ejb-name&gt;
      &lt;ejb-class&gt;net.a.g.jee.mom.ejb.MoMSenderBean&lt;/ejb-class&gt;
    &lt;/session&gt;
  &lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;
</code></pre><h3 id="configuration-des-implementations-spécifiques-jboss-ejb3xml">Configuration des implementations spécifiques (jboss-ejb3.xml)<a hidden class="anchor" aria-hidden="true" href="#configuration-des-implementations-spécifiques-jboss-ejb3xml">#</a></h3>
<p>Comme nous souhaitons pouvoir nous connecter à un serveur WebsphereMQ nous allons devoir configurer le MDB afin qu&rsquo;il réceptionne les messages. On effectura aussi le mapping des ressources d&rsquo;environnement du serveur d&rsquo;application avec les resources de l&rsquo;application.</p>
<pre tabindex="0"><code>&lt;jboss:ejb-jar xmlns:jboss=&#34;http://www.jboss.com/xml/ns/javaee&#34;
  xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34; xmlns:jee=&#34;http://java.sun.com/xml/ns/javaee&#34;
  xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:mdb=&#34;urn:resource-adapter-binding&#34;
  xsi:schemaLocation=&#34;http://www.jboss.com/xml/ns/javaee http://www.jboss.org/j2ee/schema/jboss-ejb3-2_0.xsd http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd&#34;
  version=&#34;3.1&#34; impl-version=&#34;2.0&#34;&gt;
  &lt;jee:enterprise-beans&gt;
    &lt;jee:message-driven&gt;
      &lt;jee:ejb-name&gt;MessageDrivenBean&lt;/jee:ejb-name&gt;
      &lt;jee:ejb-class&gt;net.a.g.jee.mom.mdb.MoMMDB&lt;/jee:ejb-class&gt;
      &lt;jee:transaction-type&gt;Container&lt;/jee:transaction-type&gt;
      &lt;jee:message-destination-type&gt;javax.jms.Queue&lt;/jee:message-destination-type&gt;
      &lt;jee:activation-config&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;channel&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.channel}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;queueManager&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.queueManager}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;transportType&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.transportType}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;hostName&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.hostName}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;port&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.port}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;username&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.username}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;password&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;${websphere.password}&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;destination&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;java:/jboss/jms/wmq/queue/Queue&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;useJNDI&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;true&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
        &lt;jee:activation-config-property&gt;
          &lt;jee:activation-config-property-name&gt;destinationType&lt;/jee:activation-config-property-name&gt;
          &lt;jee:activation-config-property-value&gt;javax.jms.Queue&lt;/jee:activation-config-property-value&gt;
        &lt;/jee:activation-config-property&gt;
      &lt;/jee:activation-config&gt;
    &lt;/jee:message-driven&gt;
    &lt;jee:session&gt;
      &lt;jee:ejb-name&gt;MoMSenderBean&lt;/jee:ejb-name&gt;
      &lt;jee:ejb-class&gt;net.a.g.jee.mom.ejb.MoMSenderBean&lt;/jee:ejb-class&gt;
      &lt;jee:resource-ref&gt;
        &lt;jee:res-ref-name&gt;jms/connectionFactory&lt;/jee:res-ref-name&gt;
        &lt;jee:res-type&gt;javax.jms.ConnectionFactory&lt;/jee:res-type&gt;
        &lt;jee:lookup-name&gt;java:/jboss/jms/wmq/connectionFactory&lt;/jee:lookup-name&gt;
      &lt;/jee:resource-ref&gt;
      &lt;jee:resource-env-ref&gt;
        &lt;jee:resource-env-ref-name&gt;jms/queue/Queue&lt;/jee:resource-env-ref-name&gt;
        &lt;jee:lookup-name&gt;java:/jboss/jms/wmq/queue/Queue&lt;/jee:lookup-name&gt;
      &lt;/jee:resource-env-ref&gt;
    &lt;/jee:session&gt;
  &lt;/jee:enterprise-beans&gt;
  &lt;jee:assembly-descriptor&gt;
    &lt;mdb:resource-adapter-binding&gt;
      &lt;jee:ejb-name&gt;MessageDrivenBean&lt;/jee:ejb-name&gt;
      &lt;mdb:resource-adapter-name&gt;${websphere.resource.adapter}&lt;/mdb:resource-adapter-name&gt;
    &lt;/mdb:resource-adapter-binding&gt;
  &lt;/jee:assembly-descriptor&gt;
&lt;/jboss:ejb-jar&gt;
</code></pre><p>Plusieurs points importants dans cette configuration sont à noter :</p>
<ul>
<li>L&rsquo;utilisation de placeholder dans l&rsquo;ensemble des configurations techniques afin de centraliser l&rsquo;information dans le standalone.xml
<ul>
<li><strong>hostName</strong>     -&gt; <strong>${websphere.hostName}</strong></li>
<li><strong>port</strong>         -&gt; <strong>${websphere.port}</strong></li>
<li><strong>queueManager</strong> -&gt; <strong>${websphere.queueManager}</strong></li>
</ul>
</li>
<li>La propriété <strong>useJNDI</strong> est activée afin de récuperer la queue par son nom JNDI</li>
<li>Le mapping des noms JNDI du serveur JBoss avec les noms JNDI du module applicatif
<ul>
<li>Nom de la queue configurée dans le serveur : <strong>java:/jboss/jms/wmq/queue/Queue</strong></li>
<li>Nom de la queue utilisée par le module applicatif : <strong>jms/queue/Queue</strong></li>
</ul>
</li>
<li>Le binding du ressource adapteur (driver JCA) de websphere MQ au bean MDB de réception.
<ul>
<li>Balise <strong>&lt;mdb:resource-adapter-binding&gt;</strong></li>
</ul>
</li>
</ul>
<div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>Il est preferable d&rsquo;utiliser les fichiers XML dans un contexte d&rsquo;entreprise, en effet le changement d&rsquo;environement et les fréquentes  modifications nécessite souvent des mises à jour d&rsquo;informations. Le code Java doit dépendre le moins possible de l&rsquo;environnement et de l&rsquo;implémentation des systèmes externes.</p></div>

<div class="notice info" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"></use></svg></span>Info</p><p>Si l&rsquo;application doit se connecter à un autre système JMS, je preconise de recréer un autre fichier jboss-ejb3.xml, le mapping sera de nouveau à  effectuer dans ce fichier.</p></div>

<h2 id="configuration-jboss">Configuration JBoss<a hidden class="anchor" aria-hidden="true" href="#configuration-jboss">#</a></h2>
<p>Dans ce chapitre nous allons voir comment configurer le fichier <strong>standalone.xml</strong> de l&rsquo;instance JBoss EAP.</p>
<h3 id="les-systèmes-properties">Les systèmes properties<a hidden class="anchor" aria-hidden="true" href="#les-systèmes-properties">#</a></h3>
<p>Nous reprennons ici l&rsquo;ensembles des variables d&rsquo;environnement de connexion à WebsphereMQ que nous avons vu dans le fichier <strong>jboss-ejb3.xml</strong>.</p>
<pre tabindex="0"><code>&lt;system-properties&gt;
  &lt;property name=&#34;websphere.hostName&#34;         value=&#34;localhost&#34;/&gt;
  &lt;property name=&#34;websphere.port&#34;             value=&#34;1414&#34;/&gt;
  &lt;property name=&#34;websphere.username&#34;         value=&#34;mqm&#34;/&gt;
  &lt;property name=&#34;websphere.password&#34;         value=&#34;mqm&#34;/&gt;
  &lt;property name=&#34;websphere.channel&#34;          value=&#34;SYSTEM.AUTO.SVRCONN&#34;/&gt;
  &lt;property name=&#34;websphere.transportType&#34;    value=&#34;CLIENT&#34;/&gt;
  &lt;property name=&#34;websphere.queueManager&#34;     value=&#34;QUEUE.MANAGER&#34;/&gt;
  &lt;property name=&#34;websphere.queueName&#34;        value=&#34;Q_QUEUE&#34;/&gt;
  &lt;property name=&#34;websphere.resource.adapter&#34; value=&#34;wmq.jmsra.rar&#34;/&gt;
&lt;/system-properties&gt;
</code></pre><div class="notice info" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"></use></svg></span>Info</p><p>Le mode BINDING est le second type de transport possible pour la connexion à WebsphereMQ, mais il nécessite l&rsquo;installation de composant binaires spécifiques aux systèmes d&rsquo;exploitation.</p></div>

<h3 id="le-mécanisme-de-remplacement">Le mécanisme de remplacement<a hidden class="anchor" aria-hidden="true" href="#le-mécanisme-de-remplacement">#</a></h3>
<p>JBoss va utiliser les variables d&rsquo;environnement et va les remplacer dans certain type objet de l&rsquo;application.</p>
<p>Il y a trois types de fichier dans lesquels JBoss peut remplacer les placeholder par les variables d&rsquo;environnement :</p>
<ul>
<li>Les fichiers descripteurs du standard Java EE
<ul>
<li><strong>spec-descriptor-property-replacement</strong></li>
<li>web.xml, ejb-jar.xml, etc&hellip;</li>
</ul>
</li>
<li>Les fichiers descripteurs spécifiques à JBoss
<ul>
<li><strong>jboss-descriptor-property-replacement</strong></li>
<li>jboss-web.xml, jboss-ejb3.xml, etc&hellip;</li>
</ul>
</li>
<li>Les annotations
<ul>
<li><strong>annotation-property-replacement</strong></li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>&lt;subsystem xmlns=&#34;urn:jboss:domain:ee:1.2&#34;&gt;
  &lt;spec-descriptor-property-replacement&gt;false&lt;/spec-descriptor-property-replacement&gt;
  &lt;jboss-descriptor-property-replacement&gt;true&lt;/jboss-descriptor-property-replacement&gt;
  &lt;annotation-property-replacement&gt;false&lt;/annotation-property-replacement&gt;
&lt;/subsystem&gt;
</code></pre><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>Je préconise d&rsquo;effectuer le remplacement uniquement pour les fichiers descripteurs JBoss, car cela est spécifique à JBoss.</p></div>

<h3 id="le-ressource-adapteur-pour-la-connexion-à-wmq">Le ressource adapteur pour la connexion à WMQ<a hidden class="anchor" aria-hidden="true" href="#le-ressource-adapteur-pour-la-connexion-à-wmq">#</a></h3>
<p>Enfin pour terminer, nous allons configurer le ressource adapteur dans l&rsquo;instance JBoss.</p>
<pre tabindex="0"><code>&lt;subsystem xmlns=&#34;urn:jboss:domain:resource-adapters:1.1&#34;&gt;
  &lt;resource-adapters&gt;
    &lt;resource-adapter id=&#34;wmq.jmsra.rar&#34;&gt;
      &lt;archive&gt;wmq.jmsra.rar&lt;/archive&gt;
      &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt;
      &lt;connection-definitions&gt;
        &lt;connection-definition class-name=&#34;com.ibm.mq.connector.outbound.ManagedConnectionFactoryImpl&#34; jndi-name=&#34;java:/jboss/jms/wmq/connectionFactory&#34; use-java-context=&#34;true&#34; pool-name=&#34;MQConnectionFactory&#34;&gt;
          &lt;config-property name=&#34;port&#34;&gt;${websphere.port:1414}&lt;/config-property&gt;
          &lt;config-property name=&#34;hostName&#34;&gt;${websphere.hostName:localhost}&lt;/config-property&gt;
          &lt;config-property name=&#34;username&#34;&gt;${websphere.username:mqm}&lt;/config-property&gt;
          &lt;config-property name=&#34;password&#34;&gt;${websphere.password:mqm}&lt;/config-property&gt;
          &lt;config-property name=&#34;channel&#34;&gt;${websphere.channel:SYSTEM.AUTO.SVRCONN}&lt;/config-property&gt;
          &lt;config-property name=&#34;transportType&#34;&gt;${websphere.transportType:CLIENT}&lt;/config-property&gt;
          &lt;config-property name=&#34;queueManager&#34;&gt;${websphere.queueManager:QUEUE.MANAGER}&lt;/config-property&gt;
          &lt;security&gt;
            &lt;application/&gt;
          &lt;/security&gt;
        &lt;/connection-definition&gt;
      &lt;/connection-definitions&gt;
      &lt;admin-objects&gt;
        &lt;admin-object class-name=&#34;com.ibm.mq.connector.outbound.MQQueueProxy&#34; jndi-name=&#34;java:/jboss/jms/wmq/queue/Queue&#34; use-java-context=&#34;true&#34; pool-name=&#34;QueuePool&#34;&gt;
          &lt;config-property name=&#34;baseQueueManagerName&#34;&gt;${websphere.queueManager:QUEUE.MANAGER}&lt;/config-property&gt;
          &lt;config-property name=&#34;baseQueueName&#34;&gt;${websphere.queueName:Q_QUEUE}&lt;/config-property&gt;
        &lt;/admin-object&gt;
      &lt;/admin-objects&gt;
    &lt;/resource-adapter&gt;
  &lt;/resource-adapters&gt;
&lt;/subsystem&gt;
</code></pre><div class="notice info" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"></use></svg></span>Info</p><p>On remarquera l&rsquo;utilisation des placeholders dans cette partie de configuration du fichier standalone.xml</p></div>

<p>Il nous reste plus qu&rsquo;à déposer le resource adapter de Websphere MQ <strong>wmq.jmsra.rar</strong> et notre application dans le répertoire de déploiement de l&rsquo;instance de JBoss <strong>${JBOSS_HOME}/standalone/deployments</strong>, et le tour est joué.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>L&rsquo;intégration du connecteur WebsphereMQ est relativement aisé dans le serveur d&rsquo;application JBoss. En respectant les principes de ce post, il est possible d&rsquo;obtenir une application modulaire et facile à maintenir. Le déploiement sur différents environnements (DEV, INT, PROD) en est simplifié, seules les variables d&rsquo;environnements dans le fichier <strong>standalone.xml</strong> sont à modifier.</p>
<br/>
<h3 id="url">URL<a hidden class="anchor" aria-hidden="true" href="#url">#</a></h3>
<ul>
<li><a href="https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Administration_and_Configuration_Guide/Deploy_the_WebSphere_MQ_Resource_Adapter.html">https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Administration_and_Configuration_Guide/Deploy_the_WebSphere_MQ_Resource_Adapter.html</a></li>
<li><a href="https://developer.jboss.org/message/738670">https://developer.jboss.org/message/738670</a></li>
<li><a href="https://developer.jboss.org/wiki/WebsphereMQIntegration">https://developer.jboss.org/wiki/WebsphereMQIntegration</a></li>
<li><a href="http://www-01.ibm.com/support/knowledgecenter/SSFKSJ_7.5.0/com.ibm.mq.dev.doc/q031760_.htm">The installation verification test program for the WebSphere MQ resource adapter</a></li>
<li>{% flag uk %} <a href="/blog/2015/03/26/websphere-mq-jboss-eap-integration-english-version.html">English version</a></li>
</ul>
<h3 id="remerciements">Remerciements<a hidden class="anchor" aria-hidden="true" href="#remerciements">#</a></h3>
<ul>
<li>Akram B. A. @RedHat pour certaines ressources de ce post</li>
<li>Guillaume C. @RedHat pour ces conseils</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://gautric.github.io/tags/fr/">Fr</a></li>
      <li><a href="https://gautric.github.io/tags/jboss/">JBoss</a></li>
      <li><a href="https://gautric.github.io/tags/eap/">Eap</a></li>
      <li><a href="https://gautric.github.io/tags/wildfly/">Wildfly</a></li>
      <li><a href="https://gautric.github.io/tags/webspheremq/">WebsphereMQ</a></li>
      <li><a href="https://gautric.github.io/tags/jca/">JCA</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://gautric.github.io/blog/2015/03/26/best-practices-websphere-mq/jboss-eap-6-english-version/">
    <span class="title">« Prev</span>
    <br>
    <span>Best Practices Websphere MQ/JBoss EAP 6 English Version</span>
  </a>
  <a class="next" href="https://gautric.github.io/blog/2015/03/19/yubico-otp-et-jboss-eap-6-ou-wildfly-8/">
    <span class="title">Next »</span>
    <br>
    <span>Yubico OTP et JBoss EAP 6 ou Wildfly 8</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2016 - 2024 <a href="https://gautric.github.io/">Greg. I/O</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
