<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Apache Camel RaspberryPi PoC | Greg. I/O</title>
<meta name="keywords" content="en, apache, camel, raspberry pi, ProofOfConcept">
<meta name="description" content="Integrating Apache Camel with Raspberry Pi for IoT Applications
The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.">
<meta name="author" content="">
<link rel="canonical" href="https://gautric.github.io/blog/2015/04/03/apache-camel-raspberrypi-poc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8f91d8a03d2d03df35a93d161da5378cfcf6b504ad2ef312c29e142e3806a327.css" integrity="sha256-j5HYoD0tA981qT0WHaU3jPz2tQStLvMSwp4ULjgGoyc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gautric.github.io/android-icon-36x36.png">
<link rel="apple-touch-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<link rel="mask-icon" href="https://gautric.github.io/apple-icon-180x180.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://gautric.github.io/blog/2015/04/03/apache-camel-raspberrypi-poc/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://gautric.github.io/blog/2015/04/03/apache-camel-raspberrypi-poc/">
  <meta property="og:site_name" content="Greg. I/O">
  <meta property="og:title" content="Apache Camel RaspberryPi PoC">
  <meta property="og:description" content="Integrating Apache Camel with Raspberry Pi for IoT Applications The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-04-03T13:58:00+00:00">
    <meta property="article:modified_time" content="2015-04-03T13:58:00+00:00">
    <meta property="article:tag" content="En">
    <meta property="article:tag" content="Apache">
    <meta property="article:tag" content="Camel">
    <meta property="article:tag" content="Raspberry Pi">
    <meta property="article:tag" content="ProofOfConcept">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Apache Camel RaspberryPi PoC">
<meta name="twitter:description" content="Integrating Apache Camel with Raspberry Pi for IoT Applications
The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.">
      <meta name="twitter:site" content="@gautric_io">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://gautric.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Apache Camel RaspberryPi PoC",
      "item": "https://gautric.github.io/blog/2015/04/03/apache-camel-raspberrypi-poc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Apache Camel RaspberryPi PoC",
  "name": "Apache Camel RaspberryPi PoC",
  "description": "Integrating Apache Camel with Raspberry Pi for IoT Applications The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.\n",
  "keywords": [
    "en", "apache", "camel", "raspberry pi", "ProofOfConcept"
  ],
  "articleBody": "Integrating Apache Camel with Raspberry Pi for IoT Applications The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.\nIntroduction to the Technologies The Raspberry Pi is a remarkable credit card-sized computer that costs just $35. With over five million units sold worldwide, it has become incredibly popular among hobbyists, educators, and professional developers. While the primary goal of the Raspberry Pi Foundation was to provide an affordable computer for electronic and computer science education, many electronics enthusiasts like myself have adopted it for personal projects such as home automation, environmental monitoring, and other IoT applications.\nApache Camel, on the other hand, is a powerful Enterprise Integration Patterns (EIP) framework designed to connect, process, and route messages across various technologies and protocols. It provides a consistent API for integrating different systems, making it an ideal solution for IoT applications that need to communicate with multiple services and devices.\nThis post demonstrates Apache Camel and Raspberry Pi integration as a proof of concept, showing how enterprise integration patterns can be applied to physical computing.\nLet’s examine both technologies in more detail before diving into our practical implementation.\nRaspberry Pi: Hardware for the Physical World Raspberry Pi is a versatile single-board computer with numerous features that make it ideal for IoT projects:\nBroadcom BCM2835 - ARM1176JZF-S 700 MHz processor General Purpose Input/Output (GPIO) pins for connecting sensors and actuators I2C / SPI protocols for interfacing with a wide range of electronic components USB ports for connecting peripherals HDMI port for display output Audio output capabilities Low power consumption, making it suitable for always-on applications Apache Camel: Integration Framework for the Digital World Apache Camel is a robust integration framework with extensive capabilities:\nJava framework from The Apache Software Foundation Support for numerous communication protocols: HTTP, JMS, AMQP, MQTT (ideal for IoT) FTP, SSH, IMAP/POP, IRC, SMPP Integration with multiple programming languages: Groovy, XSLT, JavaScript, Python, PHP, XPath, etc. Implementation of Enterprise Integration Patterns (EIP): Message routing, wiretap, logging, dispatching Broadcasting, dead letter channels, splitters, etc. Declarative configuration through Java DSL or XML Our Project: Building a Simple IoT Application In this tutorial, we’ll build a simple but practical IoT application that demonstrates the integration between Apache Camel and Raspberry Pi. We’ll create two prototypes:\nTimer-Controlled LED: A Camel route that uses a timer to toggle an LED on and off at regular intervals Button-Controlled LED: A more interactive version where a physical button press triggers the LED to toggle These examples will showcase how Camel can process both time-based events and physical input events to control hardware outputs, forming the foundation for more complex IoT applications.\nPrerequisites To follow along with this tutorial, you’ll need the following components:\nA Raspberry Pi (Available for purchase here) Tested with: Model B Should be compatible with: Models A, A+, B+, and 2B Raspbian OS installed on your Raspberry Pi (Download here) Electronic components: 1 LED (any color) 1 Momentary push button 1 220 Ω (ohm) resistor for the LED 4 Jumper wires 1 Breadboard for prototyping Setting Up Your Raspberry Pi Hardware Safety Warning: Always disconnect power from your Raspberry Pi before wiring any components. Double-check all connections before reconnecting power to avoid damaging your Raspberry Pi or components through short circuits or incorrect connections.\nFollow this wiring diagram to set up your circuit:\nThe circuit consists of:\nAn LED connected to GPIO pin 2 (physical pin 3) with a 220Ω resistor in series A push button connected to GPIO pin 1 (physical pin 12) You can test your wiring with the wiringpi library to ensure everything is connected properly before proceeding with the Camel integration.\nInstalling the Pi4J Library To bridge Java with the Raspberry Pi’s GPIO pins, we’ll use the Pi4J library. This library provides a convenient Java API for controlling the GPIO pins on the Raspberry Pi.\nCurrently, only the 1.0-RC version is available directly for Raspberry Pi. Install it using the following commands:\n$\u003e ssh ${PI_USER}@${PI_HOST} pi@rbpi\u003e curl -s get.pi4j.com | sudo bash Info\nTip: For faster and more convenient connections to your Raspberry Pi, consider setting up SSH with Public/Private key authentication. This eliminates the need to enter your password each time you connect.\nFor more detailed information about Pi4J installation options and configurations, visit the official Pi4J installation guide.\nCompiling the Raspberry Pi Camel Component Note: The camel-raspberry component used in this tutorial is still under development. Please feel free to test it and provide feedback. Some aspects may change in future versions, such as the URI format or available options.\nIt’s more efficient to build the camel-raspberry component on your development computer rather than on the Raspberry Pi itself, as the Pi has limited processing power and compiling Java code can be time-consuming.\nFollow these steps to checkout and build the component:\n# Clone the repository $\u003e git clone https://github.com/camel-labs/camel-labs.git # Navigate to the Raspberry Pi component directory $\u003e cd camel-labs/iot/components/camel-raspberrypi # Build the component, skipping tests for faster compilation $\u003e mvn package -Praspberry -Dmaven.test.skip=true Info\nThe camel-raspberrypi component is currently maintained in the camel-labs repository and has not yet been merged into the main Apache Camel codebase.\nCreating the Test Application Next, we need to create a simple Java application that will set up our Camel routes. Here’s the code for our main class:\npackage com.github.camellabs.component.pi4j; import org.apache.camel.CamelContext; import org.apache.camel.builder.RouteBuilder; import org.apache.camel.impl.DefaultCamelContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * A simple application to run RaspberryPi Camel routes */ public final class CamelMain { private static final Logger LOG = LoggerFactory.getLogger(CamelMain.class); private CamelMain() { } /** * Route builder that creates a route from command line arguments */ public static class CommandLineRouteBuilder extends RouteBuilder { String[] args; CommandLineRouteBuilder(String[] args) { this.args = args; } @Override public void configure() throws Exception { // Create a route from the first argument to the second argument // with logging in between from(args[0]).id(\"raspberrypi-route\").to(Pi4jConstants.LOG_COMPONENT).to(args[1]); } } public static void main(String[] args) throws Exception { LOG.info(\"main\"); // Log the command line arguments for (int i = 0; i \u003c args.length; i++) { LOG.info(\"args[\" + i + \"] =\" + args[i]); } // Create and configure the Camel context CamelContext context = new DefaultCamelContext(); context.addRoutes(new CommandLineRouteBuilder(args)); // Start the Camel context and let it run for 10 minutes context.start(); Thread.sleep(600000); context.stop(); System.exit(0); } } This program is designed to be flexible - it takes two command-line arguments:\nThe source endpoint URI (where messages come from) The target endpoint URI (where messages go to) It then creates a Camel route between these endpoints, with logging in between to help us see what’s happening.\nDeploying to the Raspberry Pi Now we need to copy the compiled JAR files and dependencies to the Raspberry Pi:\n# Navigate to the component directory $\u003e cd components/camel-raspberrypi # Create a directory on the Raspberry Pi $\u003e ssh ${PI_USER}@${PI_HOST} 'mkdir -p /home/pi/camel' # Copy the JAR files $\u003e scp target/*.jar ${PI_USER}@${PI_HOST}:/home/pi/camel Configuring Logging To help with debugging, we’ll also need to set up proper logging. Create a log4j.properties file with the following content and copy it to the /home/pi/camel directory on your Raspberry Pi:\n# # The logging properties used # log4j.rootLogger=INFO, out # uncomment the following line to turn on Camel debugging #log4j.logger.org.apache.camel=DEBUG log4j.logger.org.pi4j=ALL log4j.logger.com.github.camellabs.component.raspberrypi=ALL # CONSOLE appender not used by default log4j.appender.out=org.apache.log4j.ConsoleAppender log4j.appender.out.layout=org.apache.log4j.PatternLayout log4j.appender.out.layout.ConversionPattern=%d{ISO8601} [%30.30t] %-30.30c{1} %-5p %m%n #log4j.appender.out.layout.ConversionPattern=%d [%-15.15t] %-5p %-30.30c{1} - %m%n Prototype 1: Timer-Controlled LED Our first prototype demonstrates how to use Camel’s timer component to toggle an LED at regular intervals. This is a simple but effective way to show how Camel can control physical hardware through timed events.\nArchitecture The architecture consists of:\nA Camel Timer component that generates a message every second A Camel route that passes this message to the RaspberryPi GPIO component The RaspberryPi GPIO component that toggles the LED connected to GPIO pin 2 Running the Timer-LED Example Connect to your Raspberry Pi and run the following command:\n$\u003e ssh ${PI_USER}@${PI_HOST} pi@rbpi\u003e pi4j -r com.github.camellabs.component.raspberrypi.CamelMain \\ \"timer://foo?fixedRate=true\u0026repeatCount=60\" \\ \"raspberrypi-gpio://2?action=TOGGLE\u0026shutdownExport=true\" This command:\nUses the Pi4J wrapper to run our Java application Creates a timer endpoint that fires every second for 60 times Routes each timer event to GPIO pin 2 with the TOGGLE action The shutdownExport=true parameter ensures the GPIO pin is properly released when the application exits Video Demonstration: Timer-Controlled LED Command Line Execution Understanding the Console Output When you run the timer example, you’ll see detailed logs showing:\nThe Camel context starting up Timer events being generated Messages flowing through the route The GPIO pin being toggled Here’s a snippet of the console output:\n2015-03-31 19:53:51,863 [ main] CamelMain INFO main 2015-03-31 19:53:51,881 [ main] CamelMain INFO args[0] =timer://foo?fixedRate=true\u0026repeatCount=600 2015-03-31 19:53:51,882 [ main] CamelMain INFO args[1] =raspberrypi-gpio://2?action=TOGGLE\u0026shutdownExport=true 2015-03-31 19:53:55,306 [ main] DefaultCamelContext INFO Apache Camel 2.16-SNAPSHOT (CamelContext: camel-1) is starting ... 2015-03-31 19:54:07,283 [mel-1) thread #0 - timer://foo] RaspberryPiProducer DEBUG Exchange[Message: [Body is null]] 2015-03-31 19:54:07,285 [mel-1) thread #0 - timer://foo] RaspberryPiProducer TRACE action= TOGGLE Prototype 2: Button-Controlled LED Our second prototype builds on the first one but replaces the timer with a physical button. This creates a more interactive IoT application where a user action (pressing the button) triggers a response (toggling the LED).\nArchitecture The architecture consists of:\nA RaspberryPi GPIO consumer that listens for button presses on GPIO pin 1 A Camel route that passes button press events to the RaspberryPi GPIO producer The RaspberryPi GPIO producer that toggles the LED connected to GPIO pin 2 Running the Button-LED Example Connect to your Raspberry Pi and run the following command:\n$\u003e ssh ${PI_USER}@${PI_HOST} pi@rbpi\u003e pi4j -r com.github.camellabs.component.raspberrypi.CamelMain \\ \"raspberrypi-gpio://1?mode=DIGITAL_INPUT\u0026state=HIGH\" \\ \"raspberrypi-gpio://2?action=TOGGLE\" This command:\nCreates a GPIO input endpoint that listens for HIGH state events on pin 1 (button presses) Routes each button press event to GPIO pin 2 with the TOGGLE action When the button is pressed, the LED will toggle between on and off states Video Demonstration: Button-Controlled LED Command Line Execution Understanding the Console Output When you run the button example, you’ll see detailed logs showing:\nThe Camel context starting up The GPIO consumer listening for button events Button press events being detected Messages flowing through the route The GPIO pin being toggled Here’s a snippet of the console output:\n2015-03-31 20:09:15,667 [ pool-1-thread-1] RaspberryPiConsumer DEBUG GpioEvent pin GPIO 1, event DIGITAL_STATE_CHANGE, state HIGH 2015-03-31 20:09:16,089 [ pool-1-thread-1] raspberrypi INFO Exchange[ , Id: ID-rbpi7-46433-1427832539336-0-2 , ExchangePattern: InOnly , Properties: {CamelCreatedTimestamp=Tue Mar 31 20:09:15 UTC 2015, CamelMessageHistory=[DefaultMessageHistory[routeId=raspberry-pi, node=to1]], CamelToEndpoint=log://org.apache.camel.component.raspberrypi?multiline=true\u0026showAll=true} , Headers: {breadcrumbId=ID-rbpi7-46433-1427832539336-0-1, CamelPi4j.pin=\"GPIO 1\" , CamelPi4j.pinState=HIGH, CamelPi4j.pinType=DIGITAL_STATE_CHANGE} , BodyType: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent , Body: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent[source=com.pi4j.io.gpio.RaspiGpioProvider@aa952c] , Out: null: ] 2015-03-31 20:09:16,152 [ pool-1-thread-1] RaspberryPiProducer DEBUG Exchange[Message: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent[source=com.pi4j.io.gpio.RaspiGpioProvider@aa952c]] 2015-03-31 20:09:16,153 [ pool-1-thread-1] RaspberryPiProducer TRACE action= TOGGLE Notice how the consumer detects both the button press (HIGH state) and release (LOW state), but only processes the HIGH state events as configured.\nConclusion: The Power of Combining Camel and Raspberry Pi As demonstrated in our prototypes, integrating Apache Camel with Raspberry Pi creates a powerful platform for IoT development. This combination offers several key advantages:\nSimplified Integration: Camel’s extensive connectivity options make it easy to connect your Raspberry Pi to other systems and services using protocols like HTTP, MQTT, AMQP, and more.\nEnterprise-Grade Messaging: Leverage Camel’s robust message routing, transformation, and error handling capabilities in your IoT applications.\nScalable Architecture: Start with simple prototypes like our examples and scale to complex IoT solutions using the same technology stack.\nFuture Expansion: The Raspberry Pi can integrate with various electronic protocols such as I2C and SPI (which will be coming soon to the camel-raspberrypi component), enabling connections to a wide range of sensors and actuators.\nPotential Applications This integration opens up possibilities for numerous IoT applications, including:\nHome Automation: Control lights, appliances, and other devices through various triggers Environmental Monitoring: Collect sensor data and route it to cloud services for analysis Industrial Automation: Create small-scale control systems with enterprise-grade integration Data Collection: Gather information from physical sensors and integrate it with business systems The combination of Raspberry Pi’s hardware capabilities and Apache Camel’s integration framework creates a versatile platform for bridging the physical and digital worlds in your IoT projects.\nRaspberry Pi and Apache Camel together make a powerful combination for IoT development!\nAdditional Resources More information about me My colleague’s blog: Henryk Konsek (IoT, MQTT, etc.) CAMEL-8567 JIRA issue - Track the progress of the Raspberry Pi component GitHub Pull Request - See the code changes for the component Pi4J library - Java library for Raspberry Pi GPIO Raspberry Pi - Official Raspberry Pi website Apache Camel - Official Apache Camel website ",
  "wordCount" : "2126",
  "inLanguage": "en",
  "datePublished": "2015-04-03T13:58:00Z",
  "dateModified": "2015-04-03T13:58:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gautric.github.io/blog/2015/04/03/apache-camel-raspberrypi-poc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Greg. I/O",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gautric.github.io/apple-icon-180x180.png"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gautric.github.io/" accesskey="h" title="Greg. I/O (Alt + H)">
                <img src="https://gautric.github.io/apple-icon-180x180.png" alt="" aria-label="logo"
                    height="35">Greg. I/O</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gautric.github.io/apropos/" title="À Propos">
                    <span>À Propos</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://gautric.github.io/contact/" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://gautric.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://gautric.github.io/blog/">Blog</a></div>
    <h1 class="post-title entry-hint-parent">
      Apache Camel RaspberryPi PoC
    </h1>
    <div class="post-meta"><span title='2015-04-03 13:58:00 +0000 UTC'>April 3, 2015</span>

</div>
  </header> 
  <div class="post-content"><h1 id="integrating-apache-camel-with-raspberry-pi-for-iot-applications">Integrating Apache Camel with Raspberry Pi for IoT Applications<a hidden class="anchor" aria-hidden="true" href="#integrating-apache-camel-with-raspberry-pi-for-iot-applications">#</a></h1>
<p>The Internet of Things (IoT) revolution is transforming how we interact with the physical world through technology. At the heart of many IoT projects are two key components: affordable, capable hardware and flexible integration software. This article explores how to combine the popular Raspberry Pi single-board computer with Apache Camel, a powerful enterprise integration framework, to create IoT solutions that bridge the physical and digital worlds.</p>
<h2 id="introduction-to-the-technologies">Introduction to the Technologies<a hidden class="anchor" aria-hidden="true" href="#introduction-to-the-technologies">#</a></h2>
<p>The Raspberry Pi is a remarkable credit card-sized computer that costs just $35. With over five million units sold worldwide, it has become incredibly popular among hobbyists, educators, and professional developers. While the primary goal of the Raspberry Pi Foundation was to provide an affordable computer for electronic and computer science education, many electronics enthusiasts like myself have adopted it for personal projects such as home automation, environmental monitoring, and other IoT applications.</p>
<p>Apache Camel, on the other hand, is a powerful Enterprise Integration Patterns (EIP) framework designed to connect, process, and route messages across various technologies and protocols. It provides a consistent API for integrating different systems, making it an ideal solution for IoT applications that need to communicate with multiple services and devices.</p>
<blockquote>
<p><strong>This post demonstrates Apache Camel and Raspberry Pi integration as a proof of concept, showing how enterprise integration patterns can be applied to physical computing.</strong></p></blockquote>
<p>Let&rsquo;s examine both technologies in more detail before diving into our practical implementation.</p>
<h3 id="raspberry-pi-hardware-for-the-physical-world">Raspberry Pi: Hardware for the Physical World<a hidden class="anchor" aria-hidden="true" href="#raspberry-pi-hardware-for-the-physical-world">#</a></h3>
<p><a href="http://www.raspberrypi.org/">Raspberry Pi</a> is a versatile single-board computer with numerous features that make it ideal for IoT projects:</p>
<table>
<tr>
<td>
<img src="/img/raspberry_pi_logo.png" height="150" width="150" alt="Raspberry Pi Logo" />
</td>
<td>
<ul>
<li>Broadcom BCM2835 - ARM1176JZF-S 700 MHz processor</li>
<li>General Purpose Input/Output (GPIO) pins for connecting sensors and actuators</li>
<li>I2C / SPI protocols for interfacing with a wide range of electronic components</li>
<li>USB ports for connecting peripherals</li>
<li>HDMI port for display output</li>
<li>Audio output capabilities</li>
<li>Low power consumption, making it suitable for always-on applications</li>
</ul>
</td>
</tr>
</table>
<h3 id="apache-camel-integration-framework-for-the-digital-world">Apache Camel: Integration Framework for the Digital World<a hidden class="anchor" aria-hidden="true" href="#apache-camel-integration-framework-for-the-digital-world">#</a></h3>
<p><a href="http://camel.apache.org/">Apache Camel</a> is a robust integration framework with extensive capabilities:</p>
<table>
<tr>
<td>
<img src="/img/apache-camel-logo.jpg" height="150" width="150" alt="Apache Camel Logo"/>
</td>
<td>
<ul>
<li>Java framework from <a href="http://www.apache.org/">The Apache Software Foundation</a></li>
<li>Support for numerous communication protocols:
  <ul>
    <li>HTTP, JMS, AMQP, MQTT (ideal for IoT)</li>
    <li>FTP, SSH, IMAP/POP, IRC, SMPP</li>
  </ul>
</li>
<li>Integration with multiple programming languages:
  <ul>
    <li>Groovy, XSLT, JavaScript, Python, PHP, XPath, etc.</li>
  </ul>
</li>
<li>Implementation of Enterprise Integration Patterns (EIP):
  <ul>
    <li>Message routing, wiretap, logging, dispatching</li>
    <li>Broadcasting, dead letter channels, splitters, etc.</li>
  </ul>
</li>
<li>Declarative configuration through Java DSL or XML</li>
</ul>
</td>
</tr>
</table>
<h2 id="our-project-building-a-simple-iot-application">Our Project: Building a Simple IoT Application<a hidden class="anchor" aria-hidden="true" href="#our-project-building-a-simple-iot-application">#</a></h2>
<p>In this tutorial, we&rsquo;ll build a simple but practical IoT application that demonstrates the integration between Apache Camel and Raspberry Pi. We&rsquo;ll create two prototypes:</p>
<ol>
<li><strong>Timer-Controlled LED</strong>: A Camel route that uses a timer to toggle an LED on and off at regular intervals</li>
<li><strong>Button-Controlled LED</strong>: A more interactive version where a physical button press triggers the LED to toggle</li>
</ol>
<p>These examples will showcase how Camel can process both time-based events and physical input events to control hardware outputs, forming the foundation for more complex IoT applications.</p>
<h2 id="prerequisites">Prerequisites<a hidden class="anchor" aria-hidden="true" href="#prerequisites">#</a></h2>
<p>To follow along with this tutorial, you&rsquo;ll need the following components:</p>
<ul>
<li><strong>A Raspberry Pi</strong> (<a href="http://www.raspberrypi.org/products/">Available for purchase here</a>)
<ul>
<li>Tested with: Model B</li>
<li>Should be compatible with: Models A, A+, B+, and 2B</li>
</ul>
</li>
<li><strong>Raspbian OS</strong> installed on your Raspberry Pi (<a href="http://www.raspberrypi.org/downloads/">Download here</a>)</li>
<li><strong>Electronic components</strong>:
<ul>
<li>1 LED (any color)</li>
<li>1 Momentary push button</li>
<li>1 220 Ω (ohm) resistor for the LED</li>
<li>4 Jumper wires</li>
<li>1 Breadboard for prototyping</li>
</ul>
</li>
</ul>
<h2 id="setting-up-your-raspberry-pi-hardware">Setting Up Your Raspberry Pi Hardware<a hidden class="anchor" aria-hidden="true" href="#setting-up-your-raspberry-pi-hardware">#</a></h2>
<div><svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg></div><div class="notice error" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#error-notice"></use></svg></span></p><p><strong>Safety Warning</strong>: Always disconnect power from your Raspberry Pi before wiring any components. Double-check all connections before reconnecting power to avoid damaging your Raspberry Pi or components through short circuits or incorrect connections.</p></div>

<p>Follow this wiring diagram to set up your circuit:</p>
<p><img alt="Raspberry Pi Wiring Diagram" loading="lazy" src="/img/raspberrypi-camel-2.png"></p>
<p>The circuit consists of:</p>
<ul>
<li>An LED connected to GPIO pin 2 (physical pin 3) with a 220Ω resistor in series</li>
<li>A push button connected to GPIO pin 1 (physical pin 12)</li>
</ul>
<p>You can test your wiring with the <a href="http://wiringpi.com">wiringpi</a> library to ensure everything is connected properly before proceeding with the Camel integration.</p>
<h2 id="installing-the-pi4j-library">Installing the Pi4J Library<a hidden class="anchor" aria-hidden="true" href="#installing-the-pi4j-library">#</a></h2>
<p>To bridge Java with the Raspberry Pi&rsquo;s GPIO pins, we&rsquo;ll use the Pi4J library. This library provides a convenient Java API for controlling the GPIO pins on the Raspberry Pi.</p>
<p>Currently, only the 1.0-RC version is available directly for Raspberry Pi. Install it using the following commands:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$&gt; ssh <span class="si">${</span><span class="nv">PI_USER</span><span class="si">}</span>@<span class="si">${</span><span class="nv">PI_HOST</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">pi@rbpi&gt; curl -s get.pi4j.com <span class="p">|</span> sudo bash
</span></span></code></pre></div><div class="notice info" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"></use></svg></span>Info</p><p><strong>Tip</strong>: For faster and more convenient connections to your Raspberry Pi, consider setting up SSH with Public/Private key authentication. This eliminates the need to enter your password each time you connect.</p></div>

<p>For more detailed information about Pi4J installation options and configurations, visit the <a href="http://pi4j.com/install.html#Installation">official Pi4J installation guide</a>.</p>
<h2 id="compiling-the-raspberry-pi-camel-component">Compiling the Raspberry Pi Camel Component<a hidden class="anchor" aria-hidden="true" href="#compiling-the-raspberry-pi-camel-component">#</a></h2>
<div class="notice error" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#error-notice"></use></svg></span></p><p><strong>Note</strong>: The camel-raspberry component used in this tutorial is still under development. Please feel free to test it and provide feedback. Some aspects may change in future versions, such as the URI format or available options.</p></div>

<p>It&rsquo;s more efficient to build the camel-raspberry component on your development computer rather than on the Raspberry Pi itself, as the Pi has limited processing power and compiling Java code can be time-consuming.</p>
<p>Follow these steps to checkout and build the component:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Clone the repository</span>
</span></span><span class="line"><span class="cl">$&gt; git clone https://github.com/camel-labs/camel-labs.git
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Navigate to the Raspberry Pi component directory</span>
</span></span><span class="line"><span class="cl">$&gt; <span class="nb">cd</span> camel-labs/iot/components/camel-raspberrypi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Build the component, skipping tests for faster compilation</span>
</span></span><span class="line"><span class="cl">$&gt; mvn package -Praspberry -Dmaven.test.skip<span class="o">=</span><span class="nb">true</span>
</span></span></code></pre></div><div class="notice info" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#info-notice"></use></svg></span>Info</p><p>The camel-raspberrypi component is currently maintained in the camel-labs repository and has not yet been merged into the main Apache Camel codebase.</p></div>

<h2 id="creating-the-test-application">Creating the Test Application<a hidden class="anchor" aria-hidden="true" href="#creating-the-test-application">#</a></h2>
<p>Next, we need to create a simple Java application that will set up our Camel routes. Here&rsquo;s the code for our main class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">com.github.camellabs.component.pi4j</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.apache.camel.CamelContext</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.apache.camel.builder.RouteBuilder</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.apache.camel.impl.DefaultCamelContext</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.slf4j.Logger</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.slf4j.LoggerFactory</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * A simple application to run RaspberryPi Camel routes
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CamelMain</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Logger</span><span class="w"> </span><span class="n">LOG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoggerFactory</span><span class="p">.</span><span class="na">getLogger</span><span class="p">(</span><span class="n">CamelMain</span><span class="p">.</span><span class="na">class</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">CamelMain</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Route builder that creates a route from command line arguments
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CommandLineRouteBuilder</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">RouteBuilder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CommandLineRouteBuilder</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Create a route from the first argument to the second argument</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// with logging in between</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">from</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">).</span><span class="na">id</span><span class="p">(</span><span class="s">&#34;raspberrypi-route&#34;</span><span class="p">).</span><span class="na">to</span><span class="p">(</span><span class="n">Pi4jConstants</span><span class="p">.</span><span class="na">LOG_COMPONENT</span><span class="p">).</span><span class="na">to</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LOG</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;main&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Log the command line arguments</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">LOG</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;args[&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;] =&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Create and configure the Camel context</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CamelContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultCamelContext</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">context</span><span class="p">.</span><span class="na">addRoutes</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">CommandLineRouteBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Start the Camel context and let it run for 10 minutes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">context</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">600000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">context</span><span class="p">.</span><span class="na">stop</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">exit</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This program is designed to be flexible - it takes two command-line arguments:</p>
<ol>
<li>The source endpoint URI (where messages come from)</li>
<li>The target endpoint URI (where messages go to)</li>
</ol>
<p>It then creates a Camel route between these endpoints, with logging in between to help us see what&rsquo;s happening.</p>
<h2 id="deploying-to-the-raspberry-pi">Deploying to the Raspberry Pi<a hidden class="anchor" aria-hidden="true" href="#deploying-to-the-raspberry-pi">#</a></h2>
<p>Now we need to copy the compiled JAR files and dependencies to the Raspberry Pi:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Navigate to the component directory</span>
</span></span><span class="line"><span class="cl">$&gt; <span class="nb">cd</span> components/camel-raspberrypi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Create a directory on the Raspberry Pi</span>
</span></span><span class="line"><span class="cl">$&gt; ssh <span class="si">${</span><span class="nv">PI_USER</span><span class="si">}</span>@<span class="si">${</span><span class="nv">PI_HOST</span><span class="si">}</span> <span class="s1">&#39;mkdir -p /home/pi/camel&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Copy the JAR files</span>
</span></span><span class="line"><span class="cl">$&gt; scp target/*.jar <span class="si">${</span><span class="nv">PI_USER</span><span class="si">}</span>@<span class="si">${</span><span class="nv">PI_HOST</span><span class="si">}</span>:/home/pi/camel
</span></span></code></pre></div><h2 id="configuring-logging">Configuring Logging<a hidden class="anchor" aria-hidden="true" href="#configuring-logging">#</a></h2>
<p>To help with debugging, we&rsquo;ll also need to set up proper logging. Create a <code>log4j.properties</code> file with the following content and copy it to the <code>/home/pi/camel</code> directory on your Raspberry Pi:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-properties" data-lang="properties"><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># The logging properties used</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.rootLogger</span><span class="o">=</span><span class="s">INFO, out</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># uncomment the following line to turn on Camel debugging</span>
</span></span><span class="line"><span class="cl"><span class="c1">#log4j.logger.org.apache.camel=DEBUG</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.logger.org.pi4j</span><span class="o">=</span><span class="s">ALL</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.logger.com.github.camellabs.component.raspberrypi</span><span class="o">=</span><span class="s">ALL</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># CONSOLE appender not used by default</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.appender.out</span><span class="o">=</span><span class="s">org.apache.log4j.ConsoleAppender</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.appender.out.layout</span><span class="o">=</span><span class="s">org.apache.log4j.PatternLayout</span>
</span></span><span class="line"><span class="cl"><span class="na">log4j.appender.out.layout.ConversionPattern</span><span class="o">=</span><span class="s">%d{ISO8601} [%30.30t] %-30.30c{1} %-5p %m%n</span>
</span></span><span class="line"><span class="cl"><span class="c1">#log4j.appender.out.layout.ConversionPattern=%d [%-15.15t] %-5p %-30.30c{1} - %m%n</span>
</span></span></code></pre></div><h2 id="prototype-1-timer-controlled-led">Prototype 1: Timer-Controlled LED<a hidden class="anchor" aria-hidden="true" href="#prototype-1-timer-controlled-led">#</a></h2>
<p>Our first prototype demonstrates how to use Camel&rsquo;s timer component to toggle an LED at regular intervals. This is a simple but effective way to show how Camel can control physical hardware through timed events.</p>
<h3 id="architecture">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture">#</a></h3>
<img src="/img/camel-timer.png" alt="Timer-controlled LED architecture diagram" style="max-width:100%;" />
<p>The architecture consists of:</p>
<ol>
<li>A Camel Timer component that generates a message every second</li>
<li>A Camel route that passes this message to the RaspberryPi GPIO component</li>
<li>The RaspberryPi GPIO component that toggles the LED connected to GPIO pin 2</li>
</ol>
<h3 id="running-the-timer-led-example">Running the Timer-LED Example<a hidden class="anchor" aria-hidden="true" href="#running-the-timer-led-example">#</a></h3>
<p>Connect to your Raspberry Pi and run the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$&gt; ssh <span class="si">${</span><span class="nv">PI_USER</span><span class="si">}</span>@<span class="si">${</span><span class="nv">PI_HOST</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">pi@rbpi&gt; pi4j -r com.github.camellabs.component.raspberrypi.CamelMain  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        <span class="s2">&#34;timer://foo?fixedRate=true&amp;repeatCount=60&#34;</span>  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        <span class="s2">&#34;raspberrypi-gpio://2?action=TOGGLE&amp;shutdownExport=true&#34;</span>
</span></span></code></pre></div><p>This command:</p>
<ol>
<li>Uses the Pi4J wrapper to run our Java application</li>
<li>Creates a timer endpoint that fires every second for 60 times</li>
<li>Routes each timer event to GPIO pin 2 with the TOGGLE action</li>
<li>The <code>shutdownExport=true</code> parameter ensures the GPIO pin is properly released when the application exits</li>
</ol>
<h3 id="video-demonstration-timer-controlled-led">Video Demonstration: Timer-Controlled LED<a hidden class="anchor" aria-hidden="true" href="#video-demonstration-timer-controlled-led">#</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wxyPC5cbZrM?t=15s" frameborder="0" title="Video demonstration of timer-controlled LED"></iframe>
<h3 id="command-line-execution">Command Line Execution<a hidden class="anchor" aria-hidden="true" href="#command-line-execution">#</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/0BtJDWUMOjc" frameborder="0" title="Video showing command line execution of the timer example"></iframe>
<h3 id="understanding-the-console-output">Understanding the Console Output<a hidden class="anchor" aria-hidden="true" href="#understanding-the-console-output">#</a></h3>
<p>When you run the timer example, you&rsquo;ll see detailed logs showing:</p>
<ul>
<li>The Camel context starting up</li>
<li>Timer events being generated</li>
<li>Messages flowing through the route</li>
<li>The GPIO pin being toggled</li>
</ul>
<p>Here&rsquo;s a snippet of the console output:</p>
<pre tabindex="0"><code class="language-log" data-lang="log">2015-03-31 19:53:51,863 [                          main] CamelMain                      INFO  main
2015-03-31 19:53:51,881 [                          main] CamelMain                      INFO  args[0] =timer://foo?fixedRate=true&amp;repeatCount=600
2015-03-31 19:53:51,882 [                          main] CamelMain                      INFO  args[1] =raspberrypi-gpio://2?action=TOGGLE&amp;shutdownExport=true
2015-03-31 19:53:55,306 [                          main] DefaultCamelContext            INFO  Apache Camel 2.16-SNAPSHOT (CamelContext: camel-1) is starting
...
2015-03-31 19:54:07,283 [mel-1) thread #0 - timer://foo] RaspberryPiProducer            DEBUG Exchange[Message: [Body is null]]
2015-03-31 19:54:07,285 [mel-1) thread #0 - timer://foo] RaspberryPiProducer            TRACE action= TOGGLE
</code></pre><h2 id="prototype-2-button-controlled-led">Prototype 2: Button-Controlled LED<a hidden class="anchor" aria-hidden="true" href="#prototype-2-button-controlled-led">#</a></h2>
<p>Our second prototype builds on the first one but replaces the timer with a physical button. This creates a more interactive IoT application where a user action (pressing the button) triggers a response (toggling the LED).</p>
<h3 id="architecture-1">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture-1">#</a></h3>
<img src="/img/camel-button.png" alt="Button-controlled LED architecture diagram" style="max-width:100%;" />
<p>The architecture consists of:</p>
<ol>
<li>A RaspberryPi GPIO consumer that listens for button presses on GPIO pin 1</li>
<li>A Camel route that passes button press events to the RaspberryPi GPIO producer</li>
<li>The RaspberryPi GPIO producer that toggles the LED connected to GPIO pin 2</li>
</ol>
<h3 id="running-the-button-led-example">Running the Button-LED Example<a hidden class="anchor" aria-hidden="true" href="#running-the-button-led-example">#</a></h3>
<p>Connect to your Raspberry Pi and run the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$&gt; ssh <span class="si">${</span><span class="nv">PI_USER</span><span class="si">}</span>@<span class="si">${</span><span class="nv">PI_HOST</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">pi@rbpi&gt; pi4j -r com.github.camellabs.component.raspberrypi.CamelMain  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        <span class="s2">&#34;raspberrypi-gpio://1?mode=DIGITAL_INPUT&amp;state=HIGH&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        <span class="s2">&#34;raspberrypi-gpio://2?action=TOGGLE&#34;</span>
</span></span></code></pre></div><p>This command:</p>
<ol>
<li>Creates a GPIO input endpoint that listens for HIGH state events on pin 1 (button presses)</li>
<li>Routes each button press event to GPIO pin 2 with the TOGGLE action</li>
<li>When the button is pressed, the LED will toggle between on and off states</li>
</ol>
<h3 id="video-demonstration-button-controlled-led">Video Demonstration: Button-Controlled LED<a hidden class="anchor" aria-hidden="true" href="#video-demonstration-button-controlled-led">#</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q-r8AP9q6tE" frameborder="0" title="Video demonstration of button-controlled LED"></iframe>
<h3 id="command-line-execution-1">Command Line Execution<a hidden class="anchor" aria-hidden="true" href="#command-line-execution-1">#</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wufbxNkXx7s" frameborder="0" title="Video showing command line execution of the button example"></iframe>
<h3 id="understanding-the-console-output-1">Understanding the Console Output<a hidden class="anchor" aria-hidden="true" href="#understanding-the-console-output-1">#</a></h3>
<p>When you run the button example, you&rsquo;ll see detailed logs showing:</p>
<ul>
<li>The Camel context starting up</li>
<li>The GPIO consumer listening for button events</li>
<li>Button press events being detected</li>
<li>Messages flowing through the route</li>
<li>The GPIO pin being toggled</li>
</ul>
<p>Here&rsquo;s a snippet of the console output:</p>
<pre tabindex="0"><code class="language-log" data-lang="log">2015-03-31 20:09:15,667 [               pool-1-thread-1] RaspberryPiConsumer            DEBUG GpioEvent pin GPIO 1, event DIGITAL_STATE_CHANGE, state HIGH
2015-03-31 20:09:16,089 [               pool-1-thread-1] raspberrypi                    INFO  Exchange[
, Id: ID-rbpi7-46433-1427832539336-0-2
, ExchangePattern: InOnly
, Properties: {CamelCreatedTimestamp=Tue Mar 31 20:09:15 UTC 2015, CamelMessageHistory=[DefaultMessageHistory[routeId=raspberry-pi, node=to1]], CamelToEndpoint=log://org.apache.camel.component.raspberrypi?multiline=true&amp;showAll=true}
, Headers: {breadcrumbId=ID-rbpi7-46433-1427832539336-0-1, CamelPi4j.pin=&#34;GPIO 1&#34; &lt;GPIO 1&gt;, CamelPi4j.pinState=HIGH, CamelPi4j.pinType=DIGITAL_STATE_CHANGE}
, BodyType: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent
, Body: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent[source=com.pi4j.io.gpio.RaspiGpioProvider@aa952c]
, Out: null:
]
2015-03-31 20:09:16,152 [               pool-1-thread-1] RaspberryPiProducer            DEBUG Exchange[Message: com.pi4j.io.gpio.event.GpioPinDigitalStateChangeEvent[source=com.pi4j.io.gpio.RaspiGpioProvider@aa952c]]
2015-03-31 20:09:16,153 [               pool-1-thread-1] RaspberryPiProducer            TRACE action= TOGGLE
</code></pre><p>Notice how the consumer detects both the button press (HIGH state) and release (LOW state), but only processes the HIGH state events as configured.</p>
<h2 id="conclusion-the-power-of-combining-camel-and-raspberry-pi">Conclusion: The Power of Combining Camel and Raspberry Pi<a hidden class="anchor" aria-hidden="true" href="#conclusion-the-power-of-combining-camel-and-raspberry-pi">#</a></h2>
<p>As demonstrated in our prototypes, integrating Apache Camel with Raspberry Pi creates a powerful platform for IoT development. This combination offers several key advantages:</p>
<ol>
<li>
<p><strong>Simplified Integration</strong>: Camel&rsquo;s extensive connectivity options make it easy to connect your Raspberry Pi to other systems and services using protocols like HTTP, MQTT, AMQP, and more.</p>
</li>
<li>
<p><strong>Enterprise-Grade Messaging</strong>: Leverage Camel&rsquo;s robust message routing, transformation, and error handling capabilities in your IoT applications.</p>
</li>
<li>
<p><strong>Scalable Architecture</strong>: Start with simple prototypes like our examples and scale to complex IoT solutions using the same technology stack.</p>
</li>
<li>
<p><strong>Future Expansion</strong>: The Raspberry Pi can integrate with various electronic protocols such as I2C and SPI (which will be coming soon to the camel-raspberrypi component), enabling connections to a wide range of sensors and actuators.</p>
</li>
</ol>
<h3 id="potential-applications">Potential Applications<a hidden class="anchor" aria-hidden="true" href="#potential-applications">#</a></h3>
<p>This integration opens up possibilities for numerous IoT applications, including:</p>
<ul>
<li><strong>Home Automation</strong>: Control lights, appliances, and other devices through various triggers</li>
<li><strong>Environmental Monitoring</strong>: Collect sensor data and route it to cloud services for analysis</li>
<li><strong>Industrial Automation</strong>: Create small-scale control systems with enterprise-grade integration</li>
<li><strong>Data Collection</strong>: Gather information from physical sensors and integrate it with business systems</li>
</ul>
<p>The combination of Raspberry Pi&rsquo;s hardware capabilities and Apache Camel&rsquo;s integration framework creates a versatile platform for bridging the physical and digital worlds in your IoT projects.</p>
<p><em>Raspberry Pi and Apache Camel together make a powerful combination for IoT development!</em></p>
<h2 id="additional-resources">Additional Resources<a hidden class="anchor" aria-hidden="true" href="#additional-resources">#</a></h2>
<ul>
<li>More information <a href="/apropos/">about me</a></li>
<li>My colleague&rsquo;s blog: <a href="http://henryk-konsek.blogspot.fr/">Henryk Konsek</a> (IoT, MQTT, etc.)</li>
<li><a href="https://issues.apache.org/jira/browse/CAMEL-8567">CAMEL-8567 JIRA issue</a> - Track the progress of the Raspberry Pi component</li>
<li><a href="https://github.com/apache/camel/pull/452">GitHub Pull Request</a> - See the code changes for the component</li>
<li><a href="http://pi4j.com">Pi4J library</a> - Java library for Raspberry Pi GPIO</li>
<li><a href="http://raspberrypi.org">Raspberry Pi</a> - Official Raspberry Pi website</li>
<li><a href="http://camel.apache.org">Apache Camel</a> - Official Apache Camel website</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://gautric.github.io/tags/en/">En</a></li>
      <li><a href="https://gautric.github.io/tags/apache/">Apache</a></li>
      <li><a href="https://gautric.github.io/tags/camel/">Camel</a></li>
      <li><a href="https://gautric.github.io/tags/raspberry-pi/">Raspberry Pi</a></li>
      <li><a href="https://gautric.github.io/tags/proofofconcept/">ProofOfConcept</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://gautric.github.io/blog/2015/04/25/les-premiers-jours-du-projet-camel-iot-labs/">
    <span class="title">« Prev</span>
    <br>
    <span>Les premiers jours du projet Camel IoT Labs</span>
  </a>
  <a class="next" href="https://gautric.github.io/blog/2015/03/26/best-practices-websphere-mq/jboss-eap-6-english-version/">
    <span class="title">Next »</span>
    <br>
    <span>Best Practices Websphere MQ/JBoss EAP 6 English Version</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2016 - 2025 <a href="https://gautric.github.io/">Greg. I/O</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
